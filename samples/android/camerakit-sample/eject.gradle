import java.util.regex.Pattern

// Copies all the necessary CameraKit artifacts into an internal maven repository,
// which gets packaged within the "ejected" project so that external users don't need to
// worry about downloading artifacts from some protected repository.
task copyCameraKitDependenciesToBundledRepo() {
    def modules = [
            'camerakit-api',
            'camerakit',
            'camerakit-kotlin',
            'lenses-bundle',
            'support-camera-layout',
            'support-camera-activity',
            'support-camerax',
            'support-arcore',
            'support-snap-button',
            'support-gms-location',
            'support-permissions',
            'support-lenses-carousel',
            'support-snap-focus',
            'camerakit-plugin-api'
    ]
    def baseUri = "${snapMavenUri.replace('gcs', 'gs')}/com/snap/camerakit"
    def baseOutputDir = new File(bundledMavenRepo, '/com/snap/camerakit')

    inputs.property('version', cameraKitVersion)
    outputs.dir(baseOutputDir)
    outputs.cacheIf { true }

    doFirst {
        modules.each { module ->
            new File(baseOutputDir, module).mkdirs()
        }
    }
    doLast {
        modules.each { module ->
            // Google Cloud Storage treats + as space :/ therefore we need to convert it back to +
            // upon downloading the files and directories.
            def gcsCameraKitVersion = cameraKitVersion.replace('+', ' ')

            def moduleDir = new File(baseOutputDir, module)
            if (moduleDir.exists()) {
                moduleDir.deleteDir()
            }
            if (!moduleDir.mkdirs()) {
                throw new IOException(
                        "Failed to create directory for artifact module in: $moduleDir")
            }

            project.exec {
                commandLine 'gsutil',
                        '-m',
                        'cp',
                        '-r',
                        "$baseUri/$module/$gcsCameraKitVersion",
                        moduleDir
            }

            def moduleVersionDir = new File(moduleDir, gcsCameraKitVersion)
            def filesToRename = new LinkedHashSet<File>()
            moduleDir.eachFileRecurse { file ->
                filesToRename.add(file)
            }
            // Rename all files first before renaming their directory.
            filesToRename = filesToRename - moduleVersionDir
            filesToRename.each { file ->
                file.renameTo(new File(file.parentFile, file.name.replaceAll("\\s+", '+')))
            }
            moduleVersionDir.renameTo(new File(
                    moduleVersionDir.parentFile,
                    moduleVersionDir.name.replaceAll("\\s+", '+')
            ))
        }
    }
}

task eject(type: Copy) {
    def flavor = project.hasProperty('flavor') ?
            project.getProperty('flavor') : 'partner'

    def supportedFlavors = [
            // Includes anything that uses Snap's dev infrastructure like our GCS based Maven repo,
            // Karma (Autopilot) tests and build types used for internal testing. The code/resources
            // marked with this flavor should never be exposed outside Snap.
            'dev',
            // Same as public but includes the SDK artifacts in a bundled Maven repo so that we can
            // distribute early releases to partners without exposing features/fixes to public first
            'partner',
            // All code and resources that external world should see and be able to consume without
            // requiring to access any internal Snap services or bundled Maven repo. All SDK
            // artifacts are expected to be available on the Maven Central.
            'public'
    ]

    if (!supportedFlavors.contains(flavor)) {
        throw new IllegalArgumentException(
                "Unexpected flavor [$flavor], " +
                        "only the following are supported: [$supportedFlavors]"
        )
    }

    def outputDir = project.hasProperty('outputDir') ?
            project.getProperty('outputDir') :
            "$buildDir/eject"

    inputs.property('flavor', flavor)
    inputs.property('version', cameraKitVersion)
    outputs.dir(outputDir)
    outputs.cacheIf { true }

    from rootProject.projectDir
    into outputDir
    exclude gitignoreToList(file('.gitignore'))
    exclude 'eject.gradle'
    exclude '**/*proguard-mapping*'
    exclude 'jarRepositories.xml'
    exclude '**/build/**'
    exclude 'camerakit-sample-full/src/staging/**'
    exclude 'camerakit-sample-full/src/androidTest/resources/META-INF/**'

    if (flavor == 'public') {
        exclude '**/maven/**'
    } else {
        dependsOn copyCameraKitDependenciesToBundledRepo
    }

    doFirst {
        delete outputDir
        logger.lifecycle("Ejecting selected flavor [$flavor] to: $outputDir")
    }
    doLast {
        def flavorsToStripContent = supportedFlavors - flavor

        def filesToStrip = [
                new File(outputDir, 'build.gradle'),
                new File(outputDir, 'camerakit-sample-full/build.gradle'),
                new File(outputDir, 'camerakit-sample-simple/build.gradle'),
                new File(outputDir, 'README.md'),
        ]

        filesToStrip.each { file ->
            def strippedFileText = file.text
            flavorsToStripContent.each { flavorToStrip ->
                def tags = stripTagsFor(flavorToStrip, file)
                logger.lifecycle("Stripping [$file] contents within the tags: $tags")
                strippedFileText = stripBlockWithin(strippedFileText, tags.first, tags.second)

            }
            // Also cleanup any leftover comments for the selected flavor
            def tags = stripTagsFor(flavor, file)
            logger.lifecycle("Striping [$file] from flavor comment tags $tags")
            strippedFileText = stripAll(strippedFileText, tags.first, tags.second)

            file.write(strippedFileText)
        }
    }
}

task ejectDocs(type: Copy) {
    dependsOn copyCameraKitDependenciesToBundledRepo

    def outputDir = project.hasProperty('outputDir') ?
            project.getProperty('outputDir') :
            "$buildDir/exported-docs"

    inputs.property('version', cameraKitVersion)
    outputs.dir(outputDir)
    outputs.cacheIf { true }

    from zipTree(new File(
            bundledMavenRepo,
            "/com/snap/camerakit/camerakit/$cameraKitVersion/camerakit-$cameraKitVersion-documentation.zip"
    ))
    into outputDir

    doFirst {
        logger.lifecycle("Ejecting docs to $outputDir")
    }
}

def static gitignoreToList(File file) {
    def ignores = []
    file.eachLine { line ->
        if (!line.startsWith('#') && !line.isEmpty()) {
            ignores.add(line)
        }
    }
    return ignores
}

def static stripBlockWithin(String text, String start, String end) {
    def d1 = Pattern.quote(start)
    def d2 = Pattern.quote(end)
    def r = Pattern.compile("""(?s)$d1.*?$d2""")
    return text.replaceAll(r, "")
}

def static stripAll(String text, String... tags) {
    def r = Pattern.compile(tags.collect { tag -> Pattern.quote(tag)}.join("|"))
    return text.replaceAll(r, "")
}

def static stripTagsFor(String name, File file) {
    if (file.name.endsWith('.gradle')) {
        return new Tuple2("//$name>", "//<$name")
    } else if (file.name.endsWith('.md')) {
        return new Tuple2("<!--$name-start-->", "<!--$name-end-->")
    } else {
        throw IllegalArgumentException("Cannot determine strip tags for: $file")
    }
}
